<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Just a Recommender System Based on Google Applications Data</title>
  <meta name="description" content="A short description of the study driven">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="Just a Recommender System Based on Google Applications Data" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="A short description of the study driven" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Just a Recommender System Based on Google Applications Data" />
  
  <meta name="twitter:description" content="A short description of the study driven" />
  

<meta name="author" content="Alfredo Méndez, Eduardo D. Martínez, Alaín Cabrera, Pedro Hernández - ITAM">


<meta name="date" content="2017-05-23">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="the-shape-of-the-data.html">
<link rel="next" href="building-a-recommender-system.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Go & Google Yourself</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Abstract</a></li>
<li class="chapter" data-level="2" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>2</b> Introduction</a><ul>
<li class="chapter" data-level="2.1" data-path="introduction.html"><a href="introduction.html#go-google-yourself"><i class="fa fa-check"></i><b>2.1</b> Go Google Yourself!</a></li>
<li class="chapter" data-level="2.2" data-path="introduction.html"><a href="introduction.html#google-takeout"><i class="fa fa-check"></i><b>2.2</b> Google Takeout</a></li>
<li class="chapter" data-level="2.3" data-path="introduction.html"><a href="introduction.html#recommender-systems"><i class="fa fa-check"></i><b>2.3</b> Recommender Systems</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="the-shape-of-the-data.html"><a href="the-shape-of-the-data.html"><i class="fa fa-check"></i><b>3</b> The Shape of The Data</a><ul>
<li class="chapter" data-level="3.1" data-path="the-shape-of-the-data.html"><a href="the-shape-of-the-data.html#google-data"><i class="fa fa-check"></i><b>3.1</b> Google Data</a></li>
<li class="chapter" data-level="3.2" data-path="the-shape-of-the-data.html"><a href="the-shape-of-the-data.html#search"><i class="fa fa-check"></i><b>3.2</b> Search</a></li>
<li class="chapter" data-level="3.3" data-path="the-shape-of-the-data.html"><a href="the-shape-of-the-data.html#locations"><i class="fa fa-check"></i><b>3.3</b> Locations</a></li>
<li class="chapter" data-level="3.4" data-path="the-shape-of-the-data.html"><a href="the-shape-of-the-data.html#emails"><i class="fa fa-check"></i><b>3.4</b> Emails</a><ul>
<li class="chapter" data-level="3.4.1" data-path="the-shape-of-the-data.html"><a href="the-shape-of-the-data.html#data-pipeline"><i class="fa fa-check"></i><b>3.4.1</b> Data Pipeline</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html"><i class="fa fa-check"></i><b>4</b> Exploratory Data Analysis</a><ul>
<li class="chapter" data-level="4.1" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#network-analysis"><i class="fa fa-check"></i><b>4.1</b> Network Analysis</a></li>
<li class="chapter" data-level="4.2" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#e-mails-analysis"><i class="fa fa-check"></i><b>4.2</b> E-mails Analysis</a><ul>
<li class="chapter" data-level="4.2.1" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#plot-the-mail-traffic-by-the-day-of-the-week"><i class="fa fa-check"></i><b>4.2.1</b> Plot the mail traffic by the day of the week</a></li>
<li class="chapter" data-level="4.2.2" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#plot-the-mail-traffic-by-the-hour-of-the-day"><i class="fa fa-check"></i><b>4.2.2</b> Plot the mail traffic by the hour of the day</a></li>
<li class="chapter" data-level="4.2.3" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#plot-the-mail-traffic-by-the-minute-of-the-day"><i class="fa fa-check"></i><b>4.2.3</b> Plot the mail traffic by the minute of the day</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#locations-1"><i class="fa fa-check"></i><b>4.3</b> Locations</a></li>
<li class="chapter" data-level="4.4" data-path="exploratory-data-analysis.html"><a href="exploratory-data-analysis.html#searches"><i class="fa fa-check"></i><b>4.4</b> Searches</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html"><i class="fa fa-check"></i><b>5</b> Building a Recommender System</a><ul>
<li class="chapter" data-level="5.1" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#modular-application-framework"><i class="fa fa-check"></i><b>5.1</b> Modular Application Framework</a></li>
<li class="chapter" data-level="5.2" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#the-user-interface"><i class="fa fa-check"></i><b>5.2</b> The User Interface</a><ul>
<li class="chapter" data-level="5.2.1" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#r-shiny-keep-it-simple-alfy"><i class="fa fa-check"></i><b>5.2.1</b> R-Shiny, Keep it Simple (Alfy)</a></li>
<li class="chapter" data-level="5.2.2" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#google-maps-api-alain"><i class="fa fa-check"></i><b>5.2.2</b> Google Maps API (Alaín)</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#the-cloud-and-back-end"><i class="fa fa-check"></i><b>5.3</b> The Cloud and Back-end</a><ul>
<li class="chapter" data-level="5.3.1" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#amazon-web-services"><i class="fa fa-check"></i><b>5.3.1</b> Amazon Web Services</a></li>
<li class="chapter" data-level="5.3.2" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#merge-the-pieces"><i class="fa fa-check"></i><b>5.3.2</b> Merge the Pieces</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="building-a-recommender-system.html"><a href="building-a-recommender-system.html#further-than-beta-version"><i class="fa fa-check"></i><b>5.4</b> Further Than Beta Version</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="conclusion.html"><a href="conclusion.html"><i class="fa fa-check"></i><b>6</b> Conclusion</a></li>
<li class="chapter" data-level="7" data-path="bibliografy.html"><a href="bibliografy.html"><i class="fa fa-check"></i><b>7</b> Bibliografy</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Just a Recommender System Based on Google Applications Data</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="exploratory-data-analysis" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> Exploratory Data Analysis</h1>
<p>On every Data Science study the researcher has to follow a certain path, at this stage, once the laborious task of data manipulation is done, the next step to follow in the process is to become intimately familiar with the data set by performing Exploratory Data Analysis (EDA). The way to gain this level of understanding is to utilize the features of the statistical environment the researcher is using that support this effort.[5]</p>
<p>It is always a good idea to explore a data set with multiple exploratory techniques, especially when they can be done together for comparison. Naturally, every dataset is different, sometimes one has to deal with many features or many samples, or just the opposite. The notion that has been followed is document oriented because Google data give text, we might say that every search or every mail is a document that belongs into a <code>Corpus</code>.</p>
<p>For this development, it ain’t has a large amount of features but and important amount of effort to merge the data. Then, it is quite possible that one may need to revisit one or more data manipulation tasks in order to refine or transform the data even further. The goal of exploratory data analysis is to obtain confidence in the data to a point where one is ready to engage a machine learning algorithms.</p>
<p>On this section the reader is going to be able to replicate the Exploratory Data Analysis despiting the web app itself, with the only intention to make clear that before make modeling the researcher has to know the insights the data can say, on this study, the problem is not the number or complexity of features but how connected they are because is all about text and georeference.</p>
<div id="network-analysis" class="section level2">
<h2><span class="header-section-number">4.1</span> Network Analysis</h2>
<p>What if because of my networking one is tended to make different choices? Is it the same relevance that one send ten emails to ten persons than send ten emails to two persons?</p>
<p>Well, it is quite difficult to see at the first gaze, and maybe we have to make a deeper in-degrees and out-degrees analysis on e-mail networking. But the notion is going to follow is on popular a topic is around the net. On the image is clear to see where is the center of the graph, that center of gravity is the main user related with all the networking, then one can see communities, of course it depends on the user how big the communities is, the sure thing is that hwere is a community is a internet domain related on that community, actually the prediction is going to take the domains along with subjects to find the topics.</p>
<div class="figure">
<img src="images/graph.png" alt="graph" />
<p class="caption">graph</p>
</div>
<p>Let’s find the biggest email threads, once we got it, we visualize the longest path, using cypher query language</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql">MATCH p=(e<span class="ch">:Email</span>)&lt;-[<span class="ch">:REPLY</span>*]-(r<span class="ch">:Email</span>)&lt;-[]-(sender<span class="ch">:Account</span>)
<span class="kw">WHERE</span> <span class="kw">NOT</span> (e)-[<span class="ch">:REPLY</span>]-&gt;()
<span class="kw">RETURN</span> sender.name, e.subject, <span class="kw">Id</span>(e), <span class="fu">length</span>(p) - <span class="dv">1</span> <span class="kw">AS</span> <span class="fu">depth</span>
<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="fu">depth</span> <span class="kw">DESC</span></code></pre></div>
<p>To achieve a database based on graph we used a parser built on <a href="https://golang.org/">Go</a> programming language, helped on a ‘.mbox’ reader built in <a href="https://www.perl.org/">Perl</a></p>
<p>A little summary of <code>email2neo4j</code>package:</p>
<p><code>mbox2neo4j</code> is go command line tools that allow you to import your emails from an mbox file into a neo4j graph database. It used a model from the email example project that is explained in Chapter 3 of the book <a href="http://graphdatabases.com/">Graph Databases</a> by Ian Robinson, Jim Webber and Emil Eifrem (which is a truly great introduction to the graph btw)</p>
<p>First we have to take the attachments of the e-mails</p>
<p>On terminal:</p>
<pre><code>    perl strip-attachments.pl /path/to/mbox/file.mbox</code></pre>
<p>Then</p>
<pre><code>    mbox2neo4j /path/to/mbox/file localhost:7474</code></pre>
</div>
<div id="e-mails-analysis" class="section level2">
<h2><span class="header-section-number">4.2</span> E-mails Analysis</h2>
<p>It is important to know the distribution of the emailing traffic, then is suitable to know when recommend, as we see before the more we know the user data the accurate the recommendation.<br />
The e-mail traffic analysis through the time is partially based on <a href="http://geoffboeing.com/">Geoff Boeing</a> work, and it is been developed on <code>python</code></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> mailbox, pandas <span class="im">as</span> pd, numpy <span class="im">as</span> np 
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt, matplotlib.font_manager <span class="im">as</span> fm
<span class="im">from</span> dateutil.parser <span class="im">import</span> parse <span class="im">as</span> parse_datetime
<span class="op">%</span>matplotlib inline</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># define the fonts to use for plots</span>
<span class="co">#family = &#39;Myriad Pro&#39;</span>
family <span class="op">=</span> <span class="st">&#39;serif&#39;</span>
title_font <span class="op">=</span> fm.FontProperties(family<span class="op">=</span>family, style<span class="op">=</span><span class="st">&#39;normal&#39;</span>, size<span class="op">=</span><span class="dv">20</span>, weight<span class="op">=</span><span class="st">&#39;normal&#39;</span>, stretch<span class="op">=</span><span class="st">&#39;normal&#39;</span>)
label_font <span class="op">=</span> fm.FontProperties(family<span class="op">=</span>family, style<span class="op">=</span><span class="st">&#39;normal&#39;</span>, size<span class="op">=</span><span class="dv">16</span>, weight<span class="op">=</span><span class="st">&#39;normal&#39;</span>, stretch<span class="op">=</span><span class="st">&#39;normal&#39;</span>)
ticks_font <span class="op">=</span> fm.FontProperties(family<span class="op">=</span>family, style<span class="op">=</span><span class="st">&#39;normal&#39;</span>, size<span class="op">=</span><span class="dv">12</span>, weight<span class="op">=</span><span class="st">&#39;normal&#39;</span>, stretch<span class="op">=</span><span class="st">&#39;normal&#39;</span>)</code></pre></div>
<p>Load the Gmail archive and parse dates/times from messages</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># load the mbox file</span>
<span class="co">#path = &#39;Destacados.mbox&#39;</span>
path <span class="op">=</span> <span class="st">&#39;/Users/pedrohserrano/google-takeout/Mail/Enviados.mbox&#39;</span>
mbox <span class="op">=</span> mailbox.mbox(path)
<span class="bu">print</span>(<span class="st">&#39;There are {:,} messages in the archive.&#39;</span>.<span class="bu">format</span>(<span class="bu">len</span>(mbox)))</code></pre></div>
<p>There are 1,699 messages in the archive.</p>
<p>The Gmail mbox file includes emails and hangouts chats among its “messages”. Hangouts messages don’t have date/time, so we’ll only parse dates and times from the actual emails, and just ignore the hangouts chats. Also, some chats do have a date. To filter them out, verify that if the message has a label that the label does not include “Chat”.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="co"># get a list of the dates/times of all the messages in the mbox</span>
all_dates <span class="op">=</span> []
all_times <span class="op">=</span> []
<span class="cf">for</span> message <span class="kw">in</span> mbox:
    <span class="co"># it&#39;s an email and not a chat if there&#39;s no label, or if there&#39;s a label but it&#39;s not &#39;chat&#39;</span>
    <span class="cf">if</span> <span class="kw">not</span> <span class="st">&#39;X-Gmail-Labels&#39;</span> <span class="kw">in</span> message <span class="kw">or</span> (<span class="st">&#39;X-Gmail-Labels&#39;</span> <span class="kw">in</span> message <span class="kw">and</span> <span class="kw">not</span> <span class="st">&#39;Chat&#39;</span> <span class="kw">in</span> message[<span class="st">&#39;X-Gmail-Labels&#39;</span>]):
        <span class="cf">if</span> <span class="st">&#39;Date&#39;</span> <span class="kw">in</span> message <span class="kw">and</span> message[<span class="st">&#39;Date&#39;</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
            <span class="cf">try</span>:
                date, time <span class="op">=</span> <span class="bu">str</span>(parse_datetime(message[<span class="st">&#39;Date&#39;</span>])).split(<span class="st">&#39; &#39;</span>)
            <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:
                <span class="bu">print</span>(e, message[<span class="st">&#39;Date&#39;</span>])
            all_dates.append(date)
            all_times.append(time)
        <span class="cf">else</span>:
            <span class="co"># hangouts messages have no Date key, so skip them</span>
            <span class="cf">pass</span>
<span class="bu">print</span>(<span class="st">&#39;There are {:,} messages with dates.&#39;</span>.<span class="bu">format</span>(<span class="bu">len</span>(all_dates)))</code></pre></div>
<p>There are 1,699 messages with dates.</p>
<p>Plot the mail traffic by date</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># get the count per date</span>
date_counts <span class="op">=</span> pd.Series(all_dates).value_counts().sort_index()
<span class="bu">print</span>(<span class="st">&#39;There are {:,} dates with messages.&#39;</span>.<span class="bu">format</span>(<span class="bu">len</span>(date_counts)))
date_counts.head()

<span class="co"># not every date necessarily has a message, so fill in missing dates in the range with zeros</span>
date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="bu">min</span>(all_dates), end<span class="op">=</span><span class="bu">max</span>(all_dates), freq<span class="op">=</span><span class="st">&#39;D&#39;</span>)
index <span class="op">=</span> date_range.<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="bu">str</span>(x.date()))
date_counts <span class="op">=</span> date_counts.reindex(index, fill_value<span class="op">=</span><span class="dv">0</span>)

<span class="bu">print</span>(<span class="st">&#39;There are {:,} dates total in the range, with or without messages.&#39;</span>.<span class="bu">format</span>(<span class="bu">len</span>(date_counts)))
date_counts.head()

<span class="co"># create a series of labels for the plot: each new year&#39;s day</span>
xlabels <span class="op">=</span> pd.Series([label <span class="cf">if</span> <span class="st">&#39;01-01&#39;</span> <span class="kw">in</span> label <span class="cf">else</span> <span class="va">None</span> <span class="cf">for</span> label <span class="kw">in</span> date_counts.index])
xlabels <span class="op">=</span> xlabels[pd.notnull(xlabels)]
xlabels.head()

<span class="co"># plot the counts per day</span>
fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>[<span class="dv">15</span>, <span class="dv">5</span>])
ax <span class="op">=</span> date_counts.plot(kind<span class="op">=</span><span class="st">&#39;line&#39;</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">&#39;g&#39;</span>)

ax.grid(<span class="va">True</span>)
ax.set_xticks(xlabels.index)
ax.set_xticklabels(xlabels, rotation<span class="op">=</span><span class="dv">35</span>, rotation_mode<span class="op">=</span><span class="st">&#39;anchor&#39;</span>, ha<span class="op">=</span><span class="st">&#39;right&#39;</span>, fontproperties<span class="op">=</span>ticks_font)
ax.set_ylabel(<span class="st">&#39;Number of emails&#39;</span>, fontproperties<span class="op">=</span>label_font)
ax.set_title(<span class="st">&#39;Sent mails traffic per day&#39;</span>, fontproperties<span class="op">=</span>title_font)

fig.tight_layout()
fig.savefig(<span class="st">&#39;images/gmail-traffic-day-destacados.png&#39;</span>, dpi<span class="op">=</span><span class="dv">96</span>)
plt.show()</code></pre></div>
<div class="figure">
<img src="images/gmail-traffic-day-destacados.png" alt="gmail-traffic-day-destacados" />
<p class="caption">gmail-traffic-day-destacados</p>
</div>
<p>Plot the traffic month by month</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="co"># get the count per month</span>
all_months <span class="op">=</span> [x[:<span class="op">-</span><span class="dv">3</span>] <span class="cf">for</span> x <span class="kw">in</span> all_dates]
month_counts <span class="op">=</span> pd.Series(all_months).value_counts().sort_index()


<span class="co"># not every month necessarily has a message, so fill in missing months in the range with zeros</span>
date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="bu">min</span>(all_dates), end<span class="op">=</span><span class="bu">max</span>(all_dates), freq<span class="op">=</span><span class="st">&#39;D&#39;</span>)
months_range <span class="op">=</span> date_range.<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="bu">str</span>(x.date())[:<span class="op">-</span><span class="dv">3</span>])
index <span class="op">=</span> np.unique(months_range)
month_counts <span class="op">=</span> month_counts.reindex(index, fill_value<span class="op">=</span><span class="dv">0</span>)

<span class="co"># create a series of labels for the plot: each january</span>
xlabels <span class="op">=</span> pd.Series([label <span class="cf">if</span> <span class="st">&#39;-01&#39;</span> <span class="kw">in</span> label <span class="cf">else</span> <span class="va">None</span> <span class="cf">for</span> label <span class="kw">in</span> month_counts.index])
xlabels <span class="op">=</span> xlabels[pd.notnull(xlabels)]
xlabels.head()

<span class="co"># plot the counts per month</span>
fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>[<span class="dv">15</span>, <span class="dv">5</span>])
ax <span class="op">=</span> month_counts.plot(kind<span class="op">=</span><span class="st">&#39;line&#39;</span>, linewidth<span class="op">=</span><span class="fl">2.5</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, color<span class="op">=</span><span class="st">&#39;g&#39;</span>, marker<span class="op">=</span><span class="st">&#39;+&#39;</span>, markeredgecolor<span class="op">=</span><span class="st">&#39;g&#39;</span>)

ax.grid(<span class="va">True</span>)
ax.set_xticks(xlabels.index)
ax.set_xticklabels(xlabels, rotation<span class="op">=</span><span class="dv">35</span>, rotation_mode<span class="op">=</span><span class="st">&#39;anchor&#39;</span>, ha<span class="op">=</span><span class="st">&#39;right&#39;</span>, fontproperties<span class="op">=</span>ticks_font)
ax.set_ylabel(<span class="st">&#39;Number of emails&#39;</span>, fontproperties<span class="op">=</span>label_font)
ax.set_title(<span class="st">&#39;Sent mail traffic per month&#39;</span>, fontproperties<span class="op">=</span>title_font)

fig.tight_layout()
fig.savefig(<span class="st">&#39;images/gmail-traffic-month.png&#39;</span>, dpi<span class="op">=</span><span class="dv">96</span>)
plt.show()</code></pre></div>
<div class="figure">
<img src="images/gmail-traffic-month.png" alt="gmail-traffic-month" />
<p class="caption">gmail-traffic-month</p>
</div>
<div id="plot-the-mail-traffic-by-the-day-of-the-week" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Plot the mail traffic by the day of the week</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="co"># get the count per day of the week</span>
day_counts <span class="op">=</span> pd.DataFrame()
day_counts[<span class="st">&#39;count&#39;</span>] <span class="op">=</span> date_counts
day_counts[<span class="st">&#39;day_of_week&#39;</span>] <span class="op">=</span> date_counts.index.<span class="bu">map</span>(<span class="kw">lambda</span> x: parse_datetime(x).weekday())
mean_day_counts <span class="op">=</span> day_counts.groupby(<span class="st">&#39;day_of_week&#39;</span>)[<span class="st">&#39;count&#39;</span>].mean()
xlabels <span class="op">=</span> [<span class="st">&#39;Monday&#39;</span>, <span class="st">&#39;Tuesday&#39;</span>, <span class="st">&#39;Wednesday&#39;</span>, <span class="st">&#39;Thursday&#39;</span>, <span class="st">&#39;Friday&#39;</span>, <span class="st">&#39;Saturday&#39;</span>, <span class="st">&#39;Sunday&#39;</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>[<span class="dv">15</span>, <span class="dv">5</span>])
ax <span class="op">=</span> mean_day_counts.plot(kind<span class="op">=</span><span class="st">&#39;bar&#39;</span>, width<span class="op">=</span><span class="fl">0.6</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">&#39;g&#39;</span>, edgecolor<span class="op">=</span><span class="st">&#39;#333333&#39;</span>)

ax.yaxis.grid(<span class="va">True</span>)
ax.set_xticklabels(xlabels, rotation<span class="op">=</span><span class="dv">35</span>, rotation_mode<span class="op">=</span><span class="st">&#39;anchor&#39;</span>, ha<span class="op">=</span><span class="st">&#39;right&#39;</span>, fontproperties<span class="op">=</span>ticks_font)
<span class="cf">for</span> label <span class="kw">in</span> ax.get_yticklabels():
    label.set_fontproperties(ticks_font)

ax.set_title(<span class="st">&#39;Sent mails traffic by day of the week&#39;</span>, fontproperties<span class="op">=</span>title_font)
ax.set_xlabel(<span class="st">&#39;&#39;</span>)
ax.set_ylabel(<span class="st">&#39;Mean number of emails&#39;</span>, fontproperties<span class="op">=</span>label_font)

fig.tight_layout()
fig.savefig(<span class="st">&#39;images/gmail-traffic-day-week.png&#39;</span>, dpi<span class="op">=</span><span class="dv">96</span>)
plt.show()</code></pre></div>
<div class="figure">
<img src="images/gmail-traffic-day-week.png" alt="gmail-traffic-day-week" />
<p class="caption">gmail-traffic-day-week</p>
</div>
</div>
<div id="plot-the-mail-traffic-by-the-hour-of-the-day" class="section level3">
<h3><span class="header-section-number">4.2.2</span> Plot the mail traffic by the hour of the day</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># get the count per hour of the day</span>
times <span class="op">=</span> pd.Series(all_times).<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="st">&#39;</span><span class="sc">{:02}</span><span class="st">:00&#39;</span>.<span class="bu">format</span>(parse_datetime(x).hour))
time_counts <span class="op">=</span> times.value_counts().sort_index()
time_counts.head()

fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>[<span class="dv">15</span>, <span class="dv">5</span>])
ax <span class="op">=</span> time_counts.plot(kind<span class="op">=</span><span class="st">&#39;bar&#39;</span>, width<span class="op">=</span><span class="fl">0.8</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">&#39;g&#39;</span>, edgecolor<span class="op">=</span><span class="st">&#39;#333333&#39;</span>)

ax.yaxis.grid(<span class="va">True</span>)
ax.set_xticklabels(time_counts.index, rotation<span class="op">=</span><span class="dv">45</span>, rotation_mode<span class="op">=</span><span class="st">&#39;anchor&#39;</span>, ha<span class="op">=</span><span class="st">&#39;right&#39;</span>, fontproperties<span class="op">=</span>ticks_font)
<span class="cf">for</span> label <span class="kw">in</span> ax.get_yticklabels():
    label.set_fontproperties(ticks_font)

ax.set_title(<span class="st">&#39;Sent mails traffic by hour of the day&#39;</span>, fontproperties<span class="op">=</span>title_font)
ax.set_ylabel(<span class="st">&#39;Number of emails&#39;</span>, fontproperties<span class="op">=</span>label_font)

fig.tight_layout()
fig.savefig(<span class="st">&#39;images/gmail-traffic-hour.png&#39;</span>, dpi<span class="op">=</span><span class="dv">96</span>)
plt.show()</code></pre></div>
<div class="figure">
<img src="images/gmail-traffic-hour.png" alt="gmail-traffic-hour" />
<p class="caption">gmail-traffic-hour</p>
</div>
</div>
<div id="plot-the-mail-traffic-by-the-minute-of-the-day" class="section level3">
<h3><span class="header-section-number">4.2.3</span> Plot the mail traffic by the minute of the day</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># get the count per minute of the day, as hh:mm</span>
minutes <span class="op">=</span> pd.Series(all_times).<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="st">&#39;</span><span class="sc">{:02}</span><span class="st">:</span><span class="sc">{:02}</span><span class="st">&#39;</span>.<span class="bu">format</span>(parse_datetime(x).hour, parse_datetime(x).minute))
minute_counts <span class="op">=</span> minutes.value_counts().sort_index()

<span class="co"># not every minute necessarily has a message, so fill in missing times with zeros</span>
time_range <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="st">&#39;0:00&#39;</span>, end<span class="op">=</span><span class="st">&#39;23:59&#39;</span>, freq<span class="op">=</span><span class="st">&#39;1min&#39;</span>)
index <span class="op">=</span> time_range.<span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="st">&#39;</span><span class="sc">{:02}</span><span class="st">:</span><span class="sc">{:02}</span><span class="st">&#39;</span>.<span class="bu">format</span>(x.hour, x.minute))
minute_counts <span class="op">=</span> minute_counts.reindex(index, fill_value<span class="op">=</span><span class="dv">0</span>)

<span class="co"># create a series of labels for the plot: each new hour</span>
xlabels <span class="op">=</span> pd.Series([label <span class="cf">if</span> <span class="st">&#39;:00&#39;</span> <span class="kw">in</span> label <span class="cf">else</span> <span class="va">None</span> <span class="cf">for</span> label <span class="kw">in</span> minute_counts.index])
xlabels <span class="op">=</span> xlabels[pd.notnull(xlabels)]

<span class="co"># plot the counts per minute</span>
fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>[<span class="dv">15</span>, <span class="dv">5</span>])
ax <span class="op">=</span> minute_counts.plot(kind<span class="op">=</span><span class="st">&#39;line&#39;</span>, linewidth<span class="op">=</span><span class="fl">0.7</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">&#39;g&#39;</span>)

ax.grid(<span class="va">True</span>)
ax.set_xticks(xlabels.index)
ax.set_xticklabels(xlabels, rotation<span class="op">=</span><span class="dv">45</span>, rotation_mode<span class="op">=</span><span class="st">&#39;anchor&#39;</span>, ha<span class="op">=</span><span class="st">&#39;right&#39;</span>, fontproperties<span class="op">=</span>ticks_font)
ax.set_ylabel(<span class="st">&#39;Number of emails&#39;</span>, fontproperties<span class="op">=</span>label_font)
ax.set_title(<span class="st">&#39;Sent mails traffic by minute of the day&#39;</span>, fontproperties<span class="op">=</span>title_font)

fig.tight_layout()
fig.savefig(<span class="st">&#39;images/gmail-traffic-minute.png&#39;</span>, dpi<span class="op">=</span><span class="dv">96</span>)
plt.show()</code></pre></div>
<div class="figure">
<img src="images/gmail-traffic-minute.png" alt="gmail-traffic-hour" />
<p class="caption">gmail-traffic-hour</p>
</div>
<p>As we can see here if we want to develop a recomender system around this user better we send ads based on how likely the user is online, we can know that when he/she is writing emails down.<br />
For this user the most likely time is around 10 to eleven and 16 to 17, Tuesdays and Thursdays, and also is important to say that there’s such an active account between November and February.<br />
<img src="images/gmail-traffic-minute.png" alt="gmail-traffic-hour" /></p>
</div>
</div>
<div id="locations-1" class="section level2">
<h2><span class="header-section-number">4.3</span> Locations</h2>
<p>The main input we used is the location history file, that is because the application is going to recommend the sites of interest around the most visited places. In other words we seek to describe the daily activity of the person and define their most frequent places (home, office or school).</p>
<p>During the day, a person performs two types of activities: staying in one place or moving to another. When a person visits a place, they tend to stay at that location for at least 10 minutes (can be extended to hours in home, office or school cases) which generates at least 17 location records. When the person moves from one place to another, a series of location records are generated along the transited space. These records may or may not be close (geographically) depending on the transfer speed. If you are in a congestion, it is possible, although unlikely, to confuse the place as a visit (depending on the tolerance we take for each visit). As a result of the day, location records generate a cloud of points with areas of high and low density.</p>
<p>In order to define the places visited during the day, it is proposed to use the DBSCAN Model which is an unsupervised clusterization algorithm based on density. When we used, the DBSCAN, unclassified points and points clusters are obtained. It will be assumed that points within a cluster are variations due to GPS accuracy or internal movements within the building. Also, within the clusters are the last records obtained during the displacement towards said cluster and the first records of the transfer to the next place. In order to define the visited location (the main one), the average of the records of each cluster will be taken excluding the first and the last in order to reduce the error caused by clustering.</p>
<p>The unlabeled points correspond to transfer location records. Also, was quite hard to define the frequently places, so we used a window of 30 days in order to detect if the period of analysis is a common period or a change of address (work or school) or a holiday period.</p>
<p>Using the data of the volunteers for this study, we found out that there are approximately 816 registered locations per day, approximately 34 records per hour or one record every 34 seconds.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">from</span> sklearn.cluster <span class="im">import</span> DBSCAN
<span class="im">from</span> sklearn <span class="im">import</span> metrics
<span class="co">#from sklearn.datasets.samples_generator import make_blobs</span>
<span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler
<span class="im">import</span> pandas <span class="im">as</span> pd
<span class="im">import</span> json
<span class="im">import</span> simplejson
<span class="im">import</span> datetime
<span class="im">import</span> calendar
<span class="im">from</span> urllib.request <span class="im">import</span> urlopen,quote
<span class="im">import</span> os
<span class="im">import</span> webbrowser

<span class="co">#import operator</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#with open(&#39;Historialdeubicaciones.json&#39;, &#39;r&#39;) as fh:</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;LocationHistory2.json&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> fh:
    raw <span class="op">=</span> json.loads(fh.read())

ld <span class="op">=</span> pd.DataFrame(raw[<span class="st">&#39;locations&#39;</span>])
<span class="bu">file</span> <span class="op">=</span> <span class="bu">open</span>(<span class="st">&quot;dia.csv&quot;</span>,<span class="st">&quot;w&quot;</span>) 
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ld)):
    <span class="bu">file</span>.write(<span class="st">&quot;</span><span class="sc">{0:.7f}</span><span class="st">&quot;</span>.<span class="bu">format</span>(ld[<span class="st">&#39;latitudeE7&#39;</span>][i]<span class="op">/</span><span class="dv">10000000</span>)<span class="op">+</span><span class="st">&quot;,&quot;</span><span class="op">+</span><span class="st">&quot;</span><span class="sc">{0:.7f}</span><span class="st">&quot;</span>.<span class="bu">format</span>(ld[<span class="st">&#39;longitudeE7&#39;</span>][i]<span class="op">/</span><span class="dv">10000000</span>)<span class="op">+</span><span class="st">&#39;,&#39;</span><span class="op">+</span>ld[<span class="st">&#39;timestampMs&#39;</span>][i]<span class="op">+</span><span class="st">&#39;,&#39;</span><span class="op">+</span>
    datetime.datetime.fromtimestamp(
        <span class="bu">int</span>(ld[<span class="st">&#39;timestampMs&#39;</span>][i])<span class="op">/</span> <span class="fl">1e3</span>
    ).strftime(<span class="st">&#39;%Y-%m-</span><span class="sc">%d</span><span class="st">&#39;</span>)<span class="op">+</span><span class="st">&#39;,&#39;</span><span class="op">+</span>datetime.datetime.fromtimestamp(
        <span class="bu">int</span>(ld[<span class="st">&#39;timestampMs&#39;</span>][i])<span class="op">/</span> <span class="fl">1e3</span>
    ).strftime(<span class="st">&#39;%H:%M:%S&#39;</span>)
<span class="op">+</span><span class="st">&#39;,&#39;</span> <span class="op">+</span>calendar.day_name[datetime.datetime.fromtimestamp(<span class="bu">int</span>(ld[<span class="st">&#39;timestampMs&#39;</span>][i])<span class="op">/</span> <span class="fl">1e3</span>  ).weekday()]<span class="op">+</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>) 
<span class="bu">file</span>.close()
coords<span class="op">=</span>pd.read_csv(<span class="st">&#39;dia.csv&#39;</span>, names <span class="op">=</span> [<span class="st">&quot;lat&quot;</span>, <span class="st">&quot;lon&quot;</span>,<span class="st">&quot;timestamp&quot;</span>,<span class="st">&quot;fecha&quot;</span>,<span class="st">&quot;hora&quot;</span>,<span class="st">&quot;dia&quot;</span>])</code></pre></div>
<p>Define frequent places: 30 day window</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">coords3<span class="op">=</span>coords[coords.fecha<span class="op">==</span>coords[<span class="st">&#39;fecha&#39;</span>].unique()[<span class="dv">0</span>]]
hours<span class="op">=</span>[<span class="st">&#39;00:00:00&#39;</span>,<span class="st">&#39;01:00:00&#39;</span>,
       <span class="st">&#39;02:00:00&#39;</span>,<span class="st">&#39;03:00:00&#39;</span>,
       <span class="st">&#39;04:00:00&#39;</span>,<span class="st">&#39;05:00:00&#39;</span>,
       <span class="st">&#39;06:00:00&#39;</span>,<span class="st">&#39;07:00:00&#39;</span>,
       <span class="st">&#39;08:00:00&#39;</span>,<span class="st">&#39;09:00:00&#39;</span>,
       <span class="st">&#39;10:00:00&#39;</span>,<span class="st">&#39;11:00:00&#39;</span>,
       <span class="st">&#39;12:00:00&#39;</span>,<span class="st">&#39;13:00:00&#39;</span>,
       <span class="st">&#39;14:00:00&#39;</span>,<span class="st">&#39;15:00:00&#39;</span>,
       <span class="st">&#39;16:00:00&#39;</span>,<span class="st">&#39;17:00:00&#39;</span>,
       <span class="st">&#39;18:00:00&#39;</span>,<span class="st">&#39;19:00:00&#39;</span>,
       <span class="st">&#39;20:00:00&#39;</span>,<span class="st">&#39;21:00:00&#39;</span>,
       <span class="st">&#39;22:00:00&#39;</span>,<span class="st">&#39;23:00:00&#39;</span>,<span class="st">&#39;23:59:59&#39;</span>]


inicio<span class="op">=</span><span class="dv">0</span>
final<span class="op">=</span><span class="dv">10</span>
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(inicio,final):
    coords3<span class="op">=</span>coords3.append(coords[coords.fecha<span class="op">==</span>coords[<span class="st">&#39;fecha&#39;</span>].unique()[<span class="dv">1</span><span class="op">+</span>i]])
<span class="bu">print</span>(coords[<span class="st">&#39;fecha&#39;</span>].unique()[<span class="dv">1</span><span class="op">+</span>inicio],coords[<span class="st">&#39;fecha&#39;</span>].unique()[<span class="dv">1</span><span class="op">+</span>final])

cosa<span class="op">=</span>coords3[[<span class="st">&#39;lat&#39;</span>,<span class="st">&#39;lon&#39;</span>]]
cosa <span class="op">=</span> cosa.reset_index(drop<span class="op">=</span><span class="va">True</span>)
min_samples<span class="op">=</span>np.<span class="bu">max</span>([<span class="dv">20</span>,<span class="bu">len</span>(cosa)<span class="op">*</span>.<span class="dv">07</span>])
scaler <span class="op">=</span> StandardScaler()
scaler.fit(cosa)
X<span class="op">=</span>scaler.fit_transform(cosa)
direcciones<span class="op">=</span>{}
db <span class="op">=</span> DBSCAN(eps<span class="op">=</span><span class="fl">0.031</span>, min_samples<span class="op">=</span>min_samples).fit(X)
core_samples_mask <span class="op">=</span> np.zeros_like(db.labels_, dtype<span class="op">=</span><span class="bu">bool</span>)
core_samples_mask[db.core_sample_indices_] <span class="op">=</span> <span class="va">True</span>
labels <span class="op">=</span> db.labels_
cosa<span class="op">=</span>cosa.iloc[db.core_sample_indices_]
cosa <span class="op">=</span> cosa.reset_index(drop<span class="op">=</span><span class="va">True</span>)
recuento<span class="op">=</span>{}
<span class="co"># Number of clusters in labels, ignoring noise if present.</span>
n_clusters_ <span class="op">=</span> <span class="bu">len</span>(<span class="bu">set</span>(labels)) <span class="op">-</span> (<span class="dv">1</span> <span class="cf">if</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">in</span> labels <span class="cf">else</span> <span class="dv">0</span>)
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
unique_labels <span class="op">=</span> <span class="bu">set</span>(labels)
colors <span class="op">=</span> plt.cm.Spectral(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="bu">len</span>(unique_labels)))

clusters <span class="op">=</span> [X[labels <span class="op">==</span> i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_clusters_)]

markers<span class="op">=</span><span class="st">&quot;&quot;&quot; &quot;&quot;&quot;</span>
places<span class="op">=</span><span class="st">&quot;AIzaSyCsgMwi_tzAVkae-8Rq9v2A_kjeJF5L2kU&quot;</span>
c0<span class="op">=</span>scaler.inverse_transform(clusters[<span class="dv">0</span>])
c0r<span class="op">=</span>pd.DataFrame(data<span class="op">=</span>c0[<span class="dv">0</span>:,<span class="dv">0</span>:])
c0r.columns <span class="op">=</span> [<span class="st">&#39;lat&#39;</span>, <span class="st">&#39;lon&#39;</span>]
c0r[<span class="st">&#39;cluster&#39;</span>]<span class="op">=</span><span class="dv">0</span>
casa<span class="op">=</span>{}
matutino<span class="op">=</span>{}
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_clusters_):    
    c0<span class="op">=</span>scaler.inverse_transform(clusters[i])
    c0r<span class="op">=</span>pd.DataFrame(data<span class="op">=</span>c0[<span class="dv">0</span>:,<span class="dv">0</span>:])
    c0r.columns <span class="op">=</span> [<span class="st">&#39;lat&#39;</span>, <span class="st">&#39;lon&#39;</span>]
    c0r[<span class="st">&#39;cluster&#39;</span>]<span class="op">=</span>i
    aux<span class="op">=</span>c0r.drop_duplicates()
    aux<span class="op">=</span>aux.reset_index(drop<span class="op">=</span><span class="va">True</span>)
    horas<span class="op">=</span>coords3[(coords3[<span class="st">&#39;lat&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lat&#39;</span>].loc[<span class="dv">0</span>]) <span class="op">&amp;</span>(coords3[<span class="st">&#39;lon&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lon&#39;</span>].loc[<span class="dv">0</span>])]
    casa[i]<span class="op">=</span><span class="dv">0</span>
    matutino[i]<span class="op">=</span><span class="dv">0</span>
    vespertino<span class="op">=</span><span class="dv">0</span>
    diurno<span class="op">=</span><span class="dv">0</span>
    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(aux)):
        horas<span class="op">=</span>horas.append(coords3[(coords3[<span class="st">&#39;lat&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lat&#39;</span>].loc[k]) <span class="op">&amp;</span>(coords3[<span class="st">&#39;lon&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lon&#39;</span>].loc[k])])
    cosita<span class="op">=</span>datetime.datetime.strptime(np.<span class="bu">max</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>datetime.datetime.strptime(np.<span class="bu">min</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)
    maximo<span class="op">=</span>datetime.datetime.strptime(np.<span class="bu">max</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>cosita<span class="op">*</span><span class="dv">0</span>
    minimo<span class="op">=</span>datetime.datetime.strptime(np.<span class="bu">min</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">+</span>cosita<span class="op">*</span><span class="dv">0</span>
    bajo<span class="op">=</span><span class="st">&#39;00:00:00&#39;</span>
    alto<span class="op">=</span><span class="st">&#39;00:00:00&#39;</span>
    <span class="cf">for</span> alto <span class="kw">in</span> hours:
        temp<span class="op">=</span>horas[(horas[<span class="st">&#39;hora&#39;</span>]<span class="op">&lt;</span>alto)<span class="op">&amp;</span>(horas[<span class="st">&#39;hora&#39;</span>]<span class="op">&gt;</span>bajo)]
        recuento[alto]<span class="op">=</span><span class="bu">len</span>(temp[<span class="st">&#39;hora&#39;</span>])
        <span class="cf">if</span> ((alto<span class="op">&lt;</span><span class="st">&#39;07:00:00&#39;</span>)<span class="op">|</span>(alto<span class="op">&gt;</span><span class="st">&#39;23:00:00&#39;</span>)):
            casa[i]<span class="op">=</span>casa[i]<span class="op">+</span><span class="bu">len</span>(temp[<span class="st">&#39;hora&#39;</span>]) 
        <span class="cf">if</span> ((alto<span class="op">&lt;</span><span class="st">&#39;17:00:00&#39;</span>)<span class="op">|</span>(alto<span class="op">&gt;</span><span class="st">&#39;11:00:00&#39;</span>)):
            matutino[i]<span class="op">=</span>matutino[i]<span class="op">+</span><span class="bu">len</span>(temp[<span class="st">&#39;hora&#39;</span>])
        bajo<span class="op">=</span>alto
    util<span class="op">=</span>horas[(horas[<span class="st">&#39;hora&#39;</span>]<span class="op">&lt;</span>maximo.strftime(<span class="st">&quot;%H:%M:%S&quot;</span>))<span class="op">&amp;</span>(horas[<span class="st">&#39;hora&#39;</span>]<span class="op">&gt;</span>minimo.strftime(<span class="st">&quot;%H:%M:%S&quot;</span>))]
    <span class="cf">if</span>(<span class="bu">len</span>(util)<span class="op">&gt;</span><span class="dv">0</span>):
        lon<span class="op">=</span> np.mean(util[<span class="st">&#39;lon&#39;</span>])
        lat<span class="op">=</span> np.mean(util[<span class="st">&#39;lat&#39;</span>])  
        url_maps<span class="op">=</span><span class="st">&quot;https://maps.googleapis.com/maps/api/geocode/json?latlng=&quot;</span><span class="op">+</span><span class="bu">str</span>(lat)<span class="op">+</span><span class="st">&quot;,&quot;</span><span class="op">+</span><span class="bu">str</span>(lon)<span class="op">+</span><span class="st">&quot;&amp;key=AIzaSyCb0Wakn29V87eBdMd_fAb3DGcxAKtqtxY&quot;</span>
        <span class="cf">with</span> urlopen(url_maps) <span class="im">as</span> response:
            result<span class="op">=</span> simplejson.load(urlopen(url_maps))
        direcciones[i]<span class="op">=</span>result[<span class="st">&#39;results&#39;</span>][<span class="dv">0</span>][<span class="st">&#39;formatted_address&#39;</span>]
        url_places1<span class="op">=</span><span class="st">&quot;https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=&quot;</span><span class="op">+</span><span class="bu">str</span>(lat)<span class="op">+</span><span class="st">&quot;,&quot;</span><span class="op">+</span><span class="bu">str</span>(lon)<span class="op">+</span><span class="st">&quot;&amp;rankby=distance&quot;</span><span class="op">+</span><span class="st">&quot;&amp;types=None&quot;</span><span class="op">+</span><span class="st">&quot;&amp;key=&quot;</span><span class="op">+</span>places

        markers<span class="op">=</span>markers<span class="op">+</span><span class="st">&quot;&quot;&quot;var marker = new google.maps.Marker({</span>
<span class="st">              map: map,</span>
<span class="st">            draggable: true, icon: {</span>
<span class="st">                path: google.maps.SymbolPath.CIRCLE,</span>
<span class="st">                scale:5</span>
<span class="st">              },</span>

<span class="st">              position: {lat: &quot;&quot;&quot;</span><span class="op">+</span> <span class="bu">str</span>(lat) <span class="op">+</span><span class="st">&quot;&quot;&quot; , lng: &quot;&quot;&quot;</span><span class="op">+</span><span class="bu">str</span>(lon)<span class="op">+</span><span class="st">&quot;&quot;&quot;},</span>
<span class="st">              title: &#39;&quot;&quot;&quot;</span><span class="op">+</span>result[<span class="st">&#39;results&#39;</span>][<span class="dv">0</span>][<span class="st">&#39;formatted_address&#39;</span>]<span class="op">+</span><span class="st">&quot;&quot;&quot;cluster: &quot;&quot;&quot;</span><span class="op">+</span><span class="bu">str</span>(i)<span class="op">+</span><span class="st">&quot;&quot;&quot;&#39;</span>
<span class="st">            });&quot;&quot;&quot;</span>
centro<span class="op">=</span><span class="st">&#39;{lat:&#39;</span><span class="op">+</span> <span class="bu">str</span>(np.mean(cosa[<span class="st">&#39;lat&#39;</span>])) <span class="op">+</span><span class="st">&quot;&quot;&quot; , lng: &quot;&quot;&quot;</span><span class="op">+</span><span class="bu">str</span>(np.mean(cosa[<span class="st">&#39;lon&#39;</span>]))<span class="op">+</span><span class="st">&#39;}&#39;</span>

<span class="bu">print</span>(casa)
<span class="bu">print</span>(matutino)
<span class="bu">print</span>(direcciones)</code></pre></div>
<pre><code>2017-03-21 2017-03-11
{0: 0, 1: 914, 2: 268, 3: 0}
{0: 1386, 1: 3333, 2: 830, 3: 1040}
{0: &#39;Edificio 10, Altavista, Ciudad de México, CDMX, Mexico&#39;, 1: &#39;Cerro San Francisco 305, Campestre Churubusco, 04200 Ciudad de México, CDMX, Mexico&#39;, 2: &#39;Cto. Interior Maestro José Vasconcelos 208, Condesa, 06140 Ciudad de México, CDMX, Mexico&#39;, 3: &#39;Torre C, Av Sta Fe 505, Santa Fe, Contadero, 01219 Ciudad de México, CDMX, Mexico&#39;}</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#print(&#39;Trabajo: &#39;,direcciones[max(matutino, key=matutino.get)])</span>

aux<span class="op">=</span>[k <span class="cf">for</span> k, v <span class="kw">in</span> casa.items() <span class="cf">if</span> v <span class="op">&gt;</span> <span class="fl">0.4</span><span class="op">*</span><span class="bu">sum</span>(casa.values())]
<span class="cf">for</span> i <span class="kw">in</span> aux:
    <span class="bu">print</span>(<span class="st">&#39;Casa &#39;</span>,i,<span class="st">&#39;: &#39;</span>,direcciones[i])
    aux<span class="op">=</span>[k <span class="cf">for</span> k, v <span class="kw">in</span> matutino.items() <span class="cf">if</span> v <span class="op">&gt;</span> <span class="bu">sum</span>(matutino.values())<span class="op">/</span>(n_clusters_<span class="op">+</span><span class="dv">1</span>)]
<span class="cf">for</span> i <span class="kw">in</span> aux:
    <span class="bu">print</span>(<span class="st">&#39;Trabajo/Escuela &#39;</span>,i,<span class="st">&#39;: &#39;</span>,direcciones[i])</code></pre></div>
<p>Casa 1 : Cerro San Francisco 305, Campestre Churubusco, 04200 Ciudad de México, CDMX, Mexico Trabajo/Escuela 0 : Edificio 10, Altavista, Ciudad de México, CDMX, Mexico Trabajo/Escuela 1 : Cerro San Francisco 305, Campestre Churubusco, 04200 Ciudad de México, CDMX, Mexico</p>
<p>direcciones</p>
<p>Day</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#with open(&#39;Historialdeubicaciones.json&#39;, &#39;r&#39;) as fh:</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;LocationHistory2.json&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> fh:
    raw <span class="op">=</span> json.loads(fh.read())

ld <span class="op">=</span> pd.DataFrame(raw[<span class="st">&#39;locations&#39;</span>])
<span class="bu">file</span> <span class="op">=</span> <span class="bu">open</span>(<span class="st">&quot;dia.csv&quot;</span>,<span class="st">&quot;w&quot;</span>) 
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ld)):
    <span class="bu">file</span>.write(<span class="st">&quot;</span><span class="sc">{0:.7f}</span><span class="st">&quot;</span>.<span class="bu">format</span>(ld[<span class="st">&#39;latitudeE7&#39;</span>][i]<span class="op">/</span><span class="dv">10000000</span>)<span class="op">+</span><span class="st">&quot;,&quot;</span><span class="op">+</span><span class="st">&quot;</span><span class="sc">{0:.7f}</span><span class="st">&quot;</span>.<span class="bu">format</span>(ld[<span class="st">&#39;longitudeE7&#39;</span>][i]<span class="op">/</span><span class="dv">10000000</span>)<span class="op">+</span><span class="st">&#39;,&#39;</span><span class="op">+</span>ld[<span class="st">&#39;timestampMs&#39;</span>][i]<span class="op">+</span><span class="st">&#39;,&#39;</span><span class="op">+</span>
    datetime.datetime.fromtimestamp(
        <span class="bu">int</span>(ld[<span class="st">&#39;timestampMs&#39;</span>][i])<span class="op">/</span> <span class="fl">1e3</span>
    ).strftime(<span class="st">&#39;%Y-%m-</span><span class="sc">%d</span><span class="st">&#39;</span>)<span class="op">+</span><span class="st">&#39;,&#39;</span><span class="op">+</span>datetime.datetime.fromtimestamp(
        <span class="bu">int</span>(ld[<span class="st">&#39;timestampMs&#39;</span>][i])<span class="op">/</span> <span class="fl">1e3</span>
    ).strftime(<span class="st">&#39;%H:%M:%S&#39;</span>)
<span class="op">+</span><span class="st">&#39;,&#39;</span> <span class="op">+</span>calendar.day_name[datetime.datetime.fromtimestamp(<span class="bu">int</span>(ld[<span class="st">&#39;timestampMs&#39;</span>][i])<span class="op">/</span> <span class="fl">1e3</span>  ).weekday()]<span class="op">+</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>) 
<span class="bu">file</span>.close()
coords<span class="op">=</span>pd.read_csv(<span class="st">&#39;dia.csv&#39;</span>, names <span class="op">=</span> [<span class="st">&quot;lat&quot;</span>, <span class="st">&quot;lon&quot;</span>,<span class="st">&quot;timestamp&quot;</span>,<span class="st">&quot;fecha&quot;</span>,<span class="st">&quot;hora&quot;</span>,<span class="st">&quot;dia&quot;</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">coords2<span class="op">=</span>coords[coords.fecha<span class="op">==</span><span class="st">&#39;2017-02-02&#39;</span>]
cosa<span class="op">=</span>coords2[[<span class="st">&#39;lat&#39;</span>,<span class="st">&#39;lon&#39;</span>]]
cosa <span class="op">=</span> cosa.reset_index(drop<span class="op">=</span><span class="va">True</span>)
<span class="bu">print</span>(<span class="bu">len</span>(cosa))
min_samples<span class="op">=</span>np.<span class="bu">max</span>([<span class="dv">20</span>,<span class="bu">len</span>(cosa)<span class="op">*</span>.<span class="dv">05</span>])
<span class="bu">print</span>(<span class="st">&#39;min&#39;</span>,min_samples)
scaler <span class="op">=</span> StandardScaler()
scaler.fit(cosa)
X<span class="op">=</span>scaler.fit_transform(cosa)

db <span class="op">=</span> DBSCAN(eps<span class="op">=</span><span class="fl">0.085</span>, min_samples<span class="op">=</span>min_samples).fit(X)
core_samples_mask <span class="op">=</span> np.zeros_like(db.labels_, dtype<span class="op">=</span><span class="bu">bool</span>)
core_samples_mask[db.core_sample_indices_] <span class="op">=</span> <span class="va">True</span>
<span class="bu">print</span>(<span class="bu">len</span>(db.core_sample_indices_))
labels <span class="op">=</span> db.labels_
cosa<span class="op">=</span>cosa.iloc[db.core_sample_indices_]
cosa <span class="op">=</span> cosa.reset_index(drop<span class="op">=</span><span class="va">True</span>)

<span class="co"># Number of clusters in labels, ignoring noise if present.</span>
n_clusters_ <span class="op">=</span> <span class="bu">len</span>(<span class="bu">set</span>(labels)) <span class="op">-</span> (<span class="dv">1</span> <span class="cf">if</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">in</span> labels <span class="cf">else</span> <span class="dv">0</span>)
<span class="bu">print</span>(<span class="st">&#39;Estimated number of clusters: </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> n_clusters_)
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
unique_labels <span class="op">=</span> <span class="bu">set</span>(labels)
colors <span class="op">=</span> plt.cm.Spectral(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="bu">len</span>(unique_labels)))
<span class="cf">for</span> k, col <span class="kw">in</span> <span class="bu">zip</span>(unique_labels, colors):
    <span class="cf">if</span> k <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:
        <span class="co"># Black used for noise.</span>
        col <span class="op">=</span> <span class="st">&#39;k&#39;</span>

    class_member_mask <span class="op">=</span> (labels <span class="op">==</span> k)

    xy <span class="op">=</span> X[class_member_mask <span class="op">&amp;</span> core_samples_mask]
    plt.plot(xy[:, <span class="dv">0</span>], xy[:, <span class="dv">1</span>], <span class="st">&#39;o&#39;</span>, markerfacecolor<span class="op">=</span>col,
             markeredgecolor<span class="op">=</span><span class="st">&#39;k&#39;</span>, markersize<span class="op">=</span><span class="dv">7</span>)

    xy <span class="op">=</span> X[class_member_mask <span class="op">&amp;</span> <span class="op">~</span>core_samples_mask]
    plt.plot(xy[:, <span class="dv">0</span>], xy[:, <span class="dv">1</span>], <span class="st">&#39;o&#39;</span>, markerfacecolor<span class="op">=</span>col,
             markeredgecolor<span class="op">=</span><span class="st">&#39;k&#39;</span>, markersize<span class="op">=</span><span class="dv">2</span>)

plt.title(<span class="st">&#39;Estimated number of clusters: </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span> n_clusters_)
plt.axis(<span class="st">&#39;off&#39;</span>)
plt.show()
clusters <span class="op">=</span> [X[labels <span class="op">==</span> i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_clusters_)]

markers<span class="op">=</span><span class="st">&quot;&quot;&quot; &quot;&quot;&quot;</span>
places<span class="op">=</span><span class="st">&quot;AIzaSyCsgMwi_tzAVkae-8Rq9v2A_kjeJF5L2kU&quot;</span>
c0<span class="op">=</span>scaler.inverse_transform(clusters[<span class="dv">0</span>])
c0r<span class="op">=</span>pd.DataFrame(data<span class="op">=</span>c0[<span class="dv">0</span>:,<span class="dv">0</span>:])
c0r.columns <span class="op">=</span> [<span class="st">&#39;lat&#39;</span>, <span class="st">&#39;lon&#39;</span>]
c0r[<span class="st">&#39;cluster&#39;</span>]<span class="op">=</span><span class="dv">0</span>
intento<span class="op">=</span>c0r

<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_clusters_):    
    c0<span class="op">=</span>scaler.inverse_transform(clusters[i])
    c0r<span class="op">=</span>pd.DataFrame(data<span class="op">=</span>c0[<span class="dv">0</span>:,<span class="dv">0</span>:])
    c0r.columns <span class="op">=</span> [<span class="st">&#39;lat&#39;</span>, <span class="st">&#39;lon&#39;</span>]
    c0r[<span class="st">&#39;cluster&#39;</span>]<span class="op">=</span>i
    intento<span class="op">=</span>intento.append(c0r)
    aux<span class="op">=</span>c0r.drop_duplicates()
    aux<span class="op">=</span>aux.reset_index(drop<span class="op">=</span><span class="va">True</span>)
    horas<span class="op">=</span>coords2[(coords2[<span class="st">&#39;lat&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lat&#39;</span>].loc[<span class="dv">0</span>]) <span class="op">&amp;</span>(coords2[<span class="st">&#39;lon&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lon&#39;</span>].loc[<span class="dv">0</span>])]
    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(aux)):
        horas<span class="op">=</span>horas.append(coords2[(coords2[<span class="st">&#39;lat&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lat&#39;</span>].loc[k]) <span class="op">&amp;</span>(coords2[<span class="st">&#39;lon&#39;</span>]<span class="op">==</span>aux[<span class="st">&#39;lon&#39;</span>].loc[k])])
    cosita<span class="op">=</span>datetime.datetime.strptime(np.<span class="bu">max</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>datetime.datetime.strptime(np.<span class="bu">min</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)
    maximo<span class="op">=</span>datetime.datetime.strptime(np.<span class="bu">max</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>cosita<span class="op">*</span>.<span class="dv">1</span>
    minimo<span class="op">=</span>datetime.datetime.strptime(np.<span class="bu">min</span>(horas[<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">+</span>cosita<span class="op">*</span>.<span class="dv">1</span>
    <span class="bu">print</span> (i,maximo,minimo)
    util<span class="op">=</span>horas[(horas[<span class="st">&#39;hora&#39;</span>]<span class="op">&lt;</span>maximo.strftime(<span class="st">&quot;%H:%M:%S&quot;</span>))<span class="op">&amp;</span>(horas[<span class="st">&#39;hora&#39;</span>]<span class="op">&gt;</span>minimo.strftime(<span class="st">&quot;%H:%M:%S&quot;</span>))]
    <span class="cf">if</span>(<span class="bu">len</span>(util)<span class="op">&gt;</span><span class="dv">0</span>):
        lon<span class="op">=</span> np.mean(util[<span class="st">&#39;lon&#39;</span>])
        lat<span class="op">=</span> np.mean(util[<span class="st">&#39;lat&#39;</span>])  
        url_maps<span class="op">=</span><span class="st">&quot;https://maps.googleapis.com/maps/api/geocode/json?latlng=&quot;</span><span class="op">+</span><span class="bu">str</span>(lat)<span class="op">+</span><span class="st">&quot;,&quot;</span><span class="op">+</span><span class="bu">str</span>(lon)<span class="op">+</span><span class="st">&quot;&amp;key=AIzaSyCb0Wakn29V87eBdMd_fAb3DGcxAKtqtxY&quot;</span>
        <span class="cf">with</span> urlopen(url_maps) <span class="im">as</span> response:
            result<span class="op">=</span> simplejson.load(urlopen(url_maps))
        <span class="bu">print</span> (result[<span class="st">&#39;results&#39;</span>][<span class="dv">0</span>][<span class="st">&#39;formatted_address&#39;</span>])
        url_places1<span class="op">=</span><span class="st">&quot;https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=&quot;</span><span class="op">+</span><span class="bu">str</span>(lat)<span class="op">+</span><span class="st">&quot;,&quot;</span><span class="op">+</span><span class="bu">str</span>(lon)<span class="op">+</span><span class="st">&quot;&amp;rankby=distance&quot;</span><span class="op">+</span><span class="st">&quot;&amp;types=None&quot;</span><span class="op">+</span><span class="st">&quot;&amp;key=&quot;</span><span class="op">+</span>places
        <span class="co">#with urlopen(url_places1) as response:</span>
         <span class="co">#   result_p1= simplejson.load(urlopen(url_places1))</span>
        <span class="co">#print (&quot;están en:&quot;,result_p1[&#39;results&#39;][0][&#39;name&#39;],&#39;---&#39;,result_p1[&#39;results&#39;][0][&#39;types&#39;][0])</span>

        markers<span class="op">=</span>markers<span class="op">+</span><span class="st">&quot;&quot;&quot;var marker = new google.maps.Marker({</span>
<span class="st">              map: map,</span>
<span class="st">            draggable: true, icon: {</span>
<span class="st">                path: google.maps.SymbolPath.CIRCLE,</span>
<span class="st">                scale:5</span>
<span class="st">              },</span>

<span class="st">              position: {lat: &quot;&quot;&quot;</span><span class="op">+</span> <span class="bu">str</span>(lat) <span class="op">+</span><span class="st">&quot;&quot;&quot; , lng: &quot;&quot;&quot;</span><span class="op">+</span><span class="bu">str</span>(lon)<span class="op">+</span><span class="st">&quot;&quot;&quot;},</span>
<span class="st">              title: &#39;&quot;&quot;&quot;</span><span class="op">+</span>result[<span class="st">&#39;results&#39;</span>][<span class="dv">0</span>][<span class="st">&#39;formatted_address&#39;</span>]<span class="op">+</span><span class="st">&quot;&quot;&quot;cluster: &quot;&quot;&quot;</span><span class="op">+</span><span class="bu">str</span>(i)<span class="op">+</span><span class="st">&quot;&quot;&quot;&#39;</span>
<span class="st">            });&quot;&quot;&quot;</span>
centro<span class="op">=</span><span class="st">&#39;{lat:&#39;</span><span class="op">+</span> <span class="bu">str</span>(np.mean(cosa[<span class="st">&#39;lat&#39;</span>])) <span class="op">+</span><span class="st">&quot;&quot;&quot; , lng: &quot;&quot;&quot;</span><span class="op">+</span><span class="bu">str</span>(np.mean(cosa[<span class="st">&#39;lon&#39;</span>]))<span class="op">+</span><span class="st">&#39;}&#39;</span>
hours<span class="op">=</span>[<span class="st">&#39;00:00:00&#39;</span>,<span class="st">&#39;00:15:00&#39;</span>,<span class="st">&#39;00:30:00&#39;</span>,<span class="st">&#39;00:45:00&#39;</span>,<span class="st">&#39;01:00:00&#39;</span>,
       <span class="st">&#39;01:15:00&#39;</span>,<span class="st">&#39;01:30:00&#39;</span>,<span class="st">&#39;01:45:00&#39;</span>,<span class="st">&#39;02:00:00&#39;</span>,<span class="st">&#39;02:15:00&#39;</span>,
       <span class="st">&#39;02:30:00&#39;</span>,<span class="st">&#39;02:45:00&#39;</span>,<span class="st">&#39;03:00:00&#39;</span>,<span class="st">&#39;03:15:00&#39;</span>,<span class="st">&#39;03:30:00&#39;</span>,
       <span class="st">&#39;03:45:00&#39;</span>,<span class="st">&#39;04:00:00&#39;</span>,<span class="st">&#39;04:15:00&#39;</span>,<span class="st">&#39;04:30:00&#39;</span>,<span class="st">&#39;04:45:00&#39;</span>,
       <span class="st">&#39;05:00:00&#39;</span>,<span class="st">&#39;05:15:00&#39;</span>,<span class="st">&#39;05:30:00&#39;</span>,<span class="st">&#39;05:45:00&#39;</span>,<span class="st">&#39;06:00:00&#39;</span>,
       <span class="st">&#39;06:15:00&#39;</span>,<span class="st">&#39;06:30:00&#39;</span>,<span class="st">&#39;06:45:00&#39;</span>,<span class="st">&#39;07:00:00&#39;</span>,<span class="st">&#39;07:15:00&#39;</span>,
       <span class="st">&#39;07:30:00&#39;</span>,<span class="st">&#39;07:45:00&#39;</span>,<span class="st">&#39;08:00:00&#39;</span>,<span class="st">&#39;08:15:00&#39;</span>,<span class="st">&#39;08:30:00&#39;</span>,
       <span class="st">&#39;08:45:00&#39;</span>,<span class="st">&#39;09:00:00&#39;</span>,<span class="st">&#39;09:15:00&#39;</span>,<span class="st">&#39;09:30:00&#39;</span>,<span class="st">&#39;09:45:00&#39;</span>,
       <span class="st">&#39;10:00:00&#39;</span>,<span class="st">&#39;10:15:00&#39;</span>,<span class="st">&#39;10:30:00&#39;</span>,<span class="st">&#39;10:45:00&#39;</span>,<span class="st">&#39;11:00:00&#39;</span>,
       <span class="st">&#39;11:15:00&#39;</span>,<span class="st">&#39;11:30:00&#39;</span>,<span class="st">&#39;11:45:00&#39;</span>,<span class="st">&#39;12:00:00&#39;</span>,<span class="st">&#39;12:15:00&#39;</span>,
       <span class="st">&#39;12:30:00&#39;</span>,<span class="st">&#39;12:45:00&#39;</span>,<span class="st">&#39;13:00:00&#39;</span>,<span class="st">&#39;13:15:00&#39;</span>,<span class="st">&#39;13:30:00&#39;</span>,
       <span class="st">&#39;13:45:00&#39;</span>,<span class="st">&#39;14:00:00&#39;</span>,<span class="st">&#39;14:15:00&#39;</span>,<span class="st">&#39;14:30:00&#39;</span>,<span class="st">&#39;14:45:00&#39;</span>,
       <span class="st">&#39;15:00:00&#39;</span>,<span class="st">&#39;15:15:00&#39;</span>,<span class="st">&#39;15:30:00&#39;</span>,<span class="st">&#39;15:45:00&#39;</span>,<span class="st">&#39;16:00:00&#39;</span>,
       <span class="st">&#39;16:15:00&#39;</span>,<span class="st">&#39;16:30:00&#39;</span>,<span class="st">&#39;16:45:00&#39;</span>,<span class="st">&#39;17:00:00&#39;</span>,<span class="st">&#39;17:15:00&#39;</span>,<span class="st">&#39;17:30:00&#39;</span>,<span class="st">&#39;17:45:00&#39;</span>,
       <span class="st">&#39;18:00:00&#39;</span>,<span class="st">&#39;18:15:00&#39;</span>,<span class="st">&#39;18:30:00&#39;</span>,<span class="st">&#39;18:45:00&#39;</span>,<span class="st">&#39;19:00:00&#39;</span>,<span class="st">&#39;19:15:00&#39;</span>,<span class="st">&#39;19:30:00&#39;</span>,<span class="st">&#39;19:45:00&#39;</span>,
       <span class="st">&#39;20:00:00&#39;</span>,<span class="st">&#39;20:15:00&#39;</span>,<span class="st">&#39;20:30:00&#39;</span>,<span class="st">&#39;20:45:00&#39;</span>,<span class="st">&#39;21:00:00&#39;</span>,<span class="st">&#39;21:15:00&#39;</span>,<span class="st">&#39;21:30:00&#39;</span>,<span class="st">&#39;21:45:00&#39;</span>,
       <span class="st">&#39;22:00:00&#39;</span>,<span class="st">&#39;22:15:00&#39;</span>,<span class="st">&#39;22:30:00&#39;</span>,<span class="st">&#39;22:45:00&#39;</span>,<span class="st">&#39;23:00:00&#39;</span>,<span class="st">&#39;23:15:00&#39;</span>,<span class="st">&#39;23:30:00&#39;</span>,<span class="st">&#39;23:45:00&#39;</span>]


result <span class="op">=</span> pd.merge(coords2, intento,how<span class="op">=</span><span class="st">&#39;inner&#39;</span>, on<span class="op">=</span>[<span class="st">&#39;lat&#39;</span>, <span class="st">&#39;lon&#39;</span>])
join<span class="op">=</span>result.drop_duplicates()
bajo<span class="op">=</span><span class="st">&#39;00:00:00&#39;</span>
alto<span class="op">=</span><span class="st">&#39;00:00:00&#39;</span>
transporte<span class="op">=</span><span class="dv">0</span>
cluster<span class="op">=-</span><span class="dv">20</span>
ultima<span class="op">=</span>np.<span class="bu">min</span>(join[<span class="st">&#39;hora&#39;</span>])

<span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="bu">len</span>(hours)):
    alto<span class="op">=</span>hours[j]
    chin<span class="op">=</span>join[(join[<span class="st">&#39;hora&#39;</span>]<span class="op">&gt;</span>bajo)<span class="op">&amp;</span>(join[<span class="st">&#39;hora&#39;</span>]<span class="op">&lt;</span>alto)]

    <span class="cf">if</span> <span class="bu">len</span>(chin[<span class="st">&#39;cluster&#39;</span>].unique())<span class="op">&gt;</span><span class="dv">1</span>:
        <span class="co">#print (&#39;Cambio de cluster!!&#39;)</span>
        conflicto<span class="op">=</span>{}
        <span class="cf">for</span> i <span class="kw">in</span> chin[<span class="st">&#39;cluster&#39;</span>].unique():
            conflicto[i]<span class="op">=</span>np.<span class="bu">min</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>i][<span class="st">&#39;hora&#39;</span>])
        sorted_x <span class="op">=</span> <span class="bu">sorted</span>(conflicto.items(), key<span class="op">=</span>operator.itemgetter(<span class="dv">1</span>))
        <span class="bu">print</span>(sorted_x)
        <span class="cf">for</span> ii <span class="kw">in</span> sorted_x:
            i<span class="op">=</span>ii[<span class="dv">0</span>]

            <span class="cf">if</span> cluster<span class="op">==</span>i:
                ultima<span class="op">=</span>np.<span class="bu">max</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>])
            <span class="cf">else</span>:
                <span class="bu">print</span>(<span class="st">&#39;te fuiste de &#39;</span>,cluster,<span class="st">&#39; a las &#39;</span>,ultima)
                auxT<span class="op">=</span>ultima
                cluster<span class="op">=</span>i
                <span class="bu">print</span>(<span class="st">&#39;llegaste a &#39;</span>,cluster, <span class="st">&#39;a las &#39;</span>,np.<span class="bu">min</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>i][<span class="st">&#39;hora&#39;</span>]))
                ultima<span class="op">=</span>np.<span class="bu">max</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>])
                <span class="bu">print</span>(<span class="st">&#39;--Tiempo de traslado: &#39;</span>,(datetime.datetime.strptime(np.<span class="bu">min</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>i][<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>datetime.datetime.strptime(auxT,<span class="st">&#39;%H:%M:%S&#39;</span>)).seconds)
                transporte<span class="op">=</span> transporte<span class="op">+</span>(datetime.datetime.strptime(np.<span class="bu">min</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>i][<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>datetime.datetime.strptime(auxT,<span class="st">&#39;%H:%M:%S&#39;</span>)).seconds
    <span class="cf">else</span>: 
        <span class="cf">if</span> <span class="bu">len</span>(chin[<span class="st">&#39;cluster&#39;</span>].unique())<span class="op">==</span><span class="dv">1</span>:
            <span class="cf">if</span> cluster<span class="op">==</span>chin[<span class="st">&#39;cluster&#39;</span>].unique()[<span class="dv">0</span>]:
                ultima<span class="op">=</span>np.<span class="bu">max</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>])
            <span class="cf">else</span>: 
                <span class="cf">if</span> cluster<span class="op">==-</span><span class="dv">20</span>:
                    <span class="bu">print</span>(<span class="st">&#39;amaneciste en&#39;</span>, chin[<span class="st">&#39;cluster&#39;</span>].unique()[<span class="dv">0</span>])
                    <span class="cf">if</span> <span class="bu">len</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>])<span class="op">&gt;</span><span class="dv">0</span>:
                        ultima<span class="op">=</span>np.<span class="bu">max</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>])
                        auxT<span class="op">=</span>ultima
                        <span class="bu">print</span>(ultima,auxT)


                <span class="cf">else</span>:
                    <span class="co">#print(&#39;cambio de cluster &#39;,cluster,&#39; a &#39;,chin[&#39;cluster&#39;].unique()[0])</span>
                    <span class="bu">print</span>(<span class="st">&#39;Te fuiste de &#39;</span>,cluster,<span class="st">&#39; a las &#39;</span>,ultima)
                    auxT<span class="op">=</span>ultima
                    <span class="co">#print(&#39;Ultima ub. registrada: &#39;,np.max(chin[chin[&#39;cluster&#39;]==cluster][&#39;hora&#39;]))</span>
                    <span class="co"># print(&#39;Ultima ub. registrada para &#39;,cluster,&#39;: &#39;,cluster,ultima)</span>
                <span class="co">#print(chin[chin[&#39;cluster&#39;]==cluster])</span>
                
                cluster<span class="op">=</span>chin[<span class="st">&#39;cluster&#39;</span>].unique()[<span class="dv">0</span>]
                auxT<span class="op">=</span>ultima

                ultima<span class="op">=</span>np.<span class="bu">max</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>])
                <span class="bu">print</span>(<span class="st">&#39;Llegaste a &#39;</span>,cluster,<span class="st">&#39; a las: &#39;</span>,np.<span class="bu">min</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>]))
                <span class="bu">print</span>(<span class="st">&#39;--Tiempo de traslado: &#39;</span>,<span class="bu">str</span>(datetime.timedelta(seconds<span class="op">=</span>(datetime.datetime.strptime(np.<span class="bu">min</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>datetime.datetime.strptime(auxT,<span class="st">&#39;%H:%M:%S&#39;</span>)).seconds)))
                transporte<span class="op">=</span> transporte<span class="op">+</span>(datetime.datetime.strptime(np.<span class="bu">min</span>(chin[chin[<span class="st">&#39;cluster&#39;</span>]<span class="op">==</span>cluster][<span class="st">&#39;hora&#39;</span>]),<span class="st">&#39;%H:%M:%S&#39;</span>)<span class="op">-</span>datetime.datetime.strptime(auxT,<span class="st">&#39;%H:%M:%S&#39;</span>)).seconds
                
        <span class="co">#else:</span>
            <span class="co"># print(&#39;no hay ubicaciones registradas entre &#39;,bajo,&#39; y &#39;,alto)</span>
    bajo<span class="op">=</span>alto
    
<span class="bu">print</span> (<span class="st">&#39;En el día usaste&#39;</span>,<span class="bu">str</span>(datetime.timedelta(seconds<span class="op">=</span>transporte)),<span class="st">&#39; para desplazarte&#39;</span>)</code></pre></div>
<p>Output:</p>
<pre><code>0 1900-01-01 22:52:04.600000 1900-01-01 20:23:29.400000
Paseo de la Reforma 50, Miguel Hidalgo, 11550 Ciudad de México, CDMX, Mexico
1 1900-01-01 22:54:49.300000 1900-01-01 18:35:55.700000
Felipe Villanueva 19, Guadalupe Inn, 01020 Ciudad de México, CDMX, Mexico
2 1900-01-01 16:45:28.700000 1900-01-01 10:27:10.300000
Torre C, Av Sta Fe 505, Santa Fe, Contadero, 01219 Ciudad de México, CDMX, Mexico
3 1900-01-01 07:25:18.700000 1900-01-01 00:50:28.300000
Cerro San Francisco 309, Campestre Churubusco, 04200 Ciudad de México, CDMX, Mexico
amaneciste en 3
Llegaste a  3  a las:  00:01:07
--Tiempo de traslado:  0:00:00
Te fuiste de  3  a las  08:14:40
Llegaste a  2  a las:  09:39:53
--Tiempo de traslado:  1:25:13
Te fuiste de  2  a las  17:32:46
Llegaste a  1  a las:  18:03:34
--Tiempo de traslado:  0:30:48
Te fuiste de  1  a las  19:48:47
Llegaste a  0  a las:  20:04:55
--Tiempo de traslado:  0:16:08
Te fuiste de  0  a las  23:10:39
Llegaste a  1  a las:  23:21:48
--Tiempo de traslado:  0:11:09
En el día usaste 2:23:18  para desplazarte</code></pre>
<div class="figure">
<img src="images/clusters.png" alt="clusters" />
<p class="caption">clusters</p>
</div>
</div>
<div id="searches" class="section level2">
<h2><span class="header-section-number">4.4</span> Searches</h2>
<p>It is very important to get insights of the searches’ data because is going to help to find highlights keywords whose will deprecate the sites of interest the application is going to recommend.</p>
<p>When we analyzed the user searches, we considered two approaches that allowed us to detect relevant characteristics and activities of the user, and to use this information obtained in the recommendation.</p>
<p>First, to detect topics in a general is to build a full corpus, where we can detect general characteristics of the user using automatic clustering algorithms, then compare the different algorithms outputs and determine the number of topics.</p>
<p>Secondly, we seek to analyze the user search periods, once the most important issues are detected in the first step, to detect the periodicity in terms of frequency and search topics. In this way, we will be able to detect if the identified issues correspond to activities that the user still performs, that already has time without realizing them or that has been doing them for a long time, later we use this information in the algorithm of recommendation.</p>
<p>In both cases an automatic detection is sought. To achieve these goals we consider the following characteristics of Google searches:</p>
<ol style="list-style-type: decimal">
<li>They do not require grammatical rules to be able to show a result</li>
<li>It is advisable to perform searches without punctuation marks to achieve better results</li>
<li>Google is able to interpret languages without specifying the language in which you are writing</li>
</ol>
<p>Considering these characteristics, we observe that the steps for pre-processing the text decrease, and it is also necessary to perform it in different languages, in our case it will be done in English and Spanish, which are the most frequently used languages among our users. Although later research may include automatic language detection tools to perform automatic cleaning of the text, according to the corpus being processed.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/local/Cellar/python3/3.5.1/bin/python3</span>
<span class="im">import</span> sys
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> pandas <span class="im">as</span> pd

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:
    
    todos<span class="op">=</span>[[] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">7</span>)]
    dias<span class="op">=</span><span class="dv">0</span>

    <span class="cf">while</span> <span class="va">True</span>:

        linea <span class="op">=</span> sys.stdin.readline()
        <span class="cf">if</span> <span class="kw">not</span> linea:
            <span class="cf">break</span>
        
        <span class="co"># print(linea)</span>
        separado<span class="op">=</span>linea.split(<span class="st">&#39;,&#39;</span>)

        <span class="co"># 1 es numeroDia, 2 es nombreDia</span>
        x <span class="op">=</span> <span class="bu">int</span>(separado[<span class="dv">1</span>])
        y <span class="op">=</span> [<span class="bu">int</span>(i) <span class="cf">for</span> i <span class="kw">in</span> separado[<span class="dv">3</span>:<span class="dv">27</span>]]

        <span class="co">#print(separado)</span>
        <span class="co">#print(y)</span>
        
        todos[x].append(y)
        dias<span class="op">+=</span><span class="dv">1</span>
    
    fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, ncols<span class="op">=</span><span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))

    axes[<span class="dv">0</span>][<span class="dv">0</span>].set_title(<span class="st">&#39;Lunes&#39;</span>)
    axes[<span class="dv">0</span>][<span class="dv">1</span>].set_title(<span class="st">&#39;Martes&#39;</span>)
    axes[<span class="dv">0</span>][<span class="dv">2</span>].set_title(<span class="st">&#39;Miercoles&#39;</span>)
    axes[<span class="dv">0</span>][<span class="dv">3</span>].set_title(<span class="st">&#39;Jueves&#39;</span>)
    axes[<span class="dv">1</span>][<span class="dv">0</span>].set_title(<span class="st">&#39;Viernes&#39;</span>)
    axes[<span class="dv">1</span>][<span class="dv">1</span>].set_title(<span class="st">&#39;Sabado&#39;</span>)
    axes[<span class="dv">1</span>][<span class="dv">2</span>].set_title(<span class="st">&#39;Domingo&#39;</span>)
    
    numdia <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):
        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):
            <span class="cf">if</span> <span class="kw">not</span> (j <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> i <span class="op">&gt;</span> <span class="dv">2</span>):
                dia <span class="op">=</span> np.array(todos[numdia])
                numdia<span class="op">+=</span><span class="dv">1</span>

                bar_l <span class="op">=</span> [i<span class="op">+</span><span class="dv">1</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">24</span>)]
                performance<span class="op">=</span>dia.mean(<span class="dv">0</span>)
                error<span class="op">=</span>dia.std(<span class="dv">0</span>)
                
                <span class="co"># axes[j][i].barh(bar_l, performance, xerr=error, align=&#39;center&#39;,alpha = 0.5, color=&#39;green&#39;, ecolor=&#39;gray&#39;)</span>
                axes[j][i].errorbar(bar_l, performance, yerr<span class="op">=</span>error, fmt<span class="op">=</span><span class="st">&#39;o&#39;</span>)

    <span class="co"># adding horizontal grid lines</span>
    <span class="co">#for ax in axes:</span>
    <span class="co">#    ax.yaxis.grid(True)</span>
    <span class="co">#    ax.set_xticks([y+1 for y in range(len(all_data))])</span>
    <span class="co">#    ax.set_xlabel(&#39;xlabel&#39;)</span>
    <span class="co">#    ax.set_ylabel(&#39;ylabel&#39;)</span>

    <span class="bu">print</span>(<span class="st">&quot;dias: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(dias))
    <span class="co"># add x-tick labels</span>
    <span class="co">#plt.setp(axes, xticks=[y+1 for y in range(len(all_data))],</span>
    <span class="co">#         xticklabels=[&#39;x1&#39;, &#39;x2&#39;, &#39;x3&#39;, &#39;x4&#39;])</span>
    plt.show()</code></pre></div>
<div class="figure">
<img src="./images/search-frequency.png" alt="search-frequency" />
<p class="caption">search-frequency</p>
</div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="im">from</span> datetime <span class="im">import</span> timedelta, datetime
<span class="im">import</span> json
<span class="im">import</span> sys
<span class="im">import</span> operator

<span class="kw">def</span> daterange(start_date, end_date):
    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">int</span> ((end_date <span class="op">-</span> start_date).days)):
        <span class="cf">yield</span> start_date <span class="op">+</span> timedelta(n)

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:

    <span class="cf">while</span> <span class="va">True</span>:
        x <span class="op">=</span> sys.stdin.readline()

        x <span class="op">=</span> x.replace(<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>, <span class="st">&#39;&#39;</span>)
        <span class="cf">if</span> <span class="kw">not</span> x:
            <span class="cf">break</span>
        <span class="co"># print(x) # mostrar nombre del archivo</span>

        datemin<span class="op">=</span>datetime.now() 
        datemax<span class="op">=</span>datetime.fromtimestamp(<span class="dv">0</span><span class="op">/</span><span class="fl">1e6</span>)
        <span class="cf">with</span> <span class="bu">open</span>(x) <span class="im">as</span> data_file:
            data <span class="op">=</span> json.load(data_file)

            dias <span class="op">=</span> {}
            i<span class="op">=</span><span class="dv">0</span>
            <span class="cf">for</span> query <span class="kw">in</span> data[<span class="st">&#39;event&#39;</span>]:

                    query_text <span class="op">=</span> query[<span class="st">&#39;query&#39;</span>][<span class="st">&#39;query_text&#39;</span>]
                    timestamp <span class="op">=</span> <span class="bu">int</span>(query[<span class="st">&#39;query&#39;</span>][<span class="st">&#39;id&#39;</span>][<span class="dv">0</span>][<span class="st">&#39;timestamp_usec&#39;</span>])
                    date <span class="op">=</span> datetime.fromtimestamp(timestamp<span class="op">/</span><span class="fl">1e6</span>)
                    
                    nombredia <span class="op">=</span> date.strftime(<span class="st">&quot;%A&quot;</span>)
                    diasemana <span class="op">=</span> date.weekday()

                    <span class="cf">if</span> date <span class="op">&gt;</span> datemax:
                        datemax<span class="op">=</span>date

                    <span class="cf">if</span> date <span class="op">&lt;</span> datemin:
                        datemin<span class="op">=</span>date

                    <span class="bu">hash</span> <span class="op">=</span> date.year <span class="op">*</span> <span class="dv">10000</span> <span class="op">+</span> date.month <span class="op">*</span> <span class="dv">100</span> <span class="op">+</span> date.day

                    <span class="cf">if</span> <span class="bu">hash</span> <span class="kw">in</span> dias.keys():
                        dias[<span class="bu">hash</span>][date.hour<span class="op">+</span><span class="dv">2</span>]<span class="op">+=</span><span class="dv">1</span>
                    <span class="cf">else</span>:
                        dias[<span class="bu">hash</span>]<span class="op">=</span>[<span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">24</span>)]
                        dias[<span class="bu">hash</span>].insert(<span class="dv">0</span>,nombredia)
                        dias[<span class="bu">hash</span>].insert(<span class="dv">0</span>,diasemana)
                        dias[<span class="bu">hash</span>][date.hour<span class="op">+</span><span class="dv">2</span>]<span class="op">+=</span><span class="dv">1</span>

            <span class="co"># print(&quot;num dias con consultas: {}&quot;.format(len(dias)))</span>

        

        <span class="cf">for</span> date <span class="kw">in</span> daterange(datemin, datemax):
            <span class="bu">hash</span> <span class="op">=</span> date.year <span class="op">*</span> <span class="dv">10000</span> <span class="op">+</span> date.month <span class="op">*</span> <span class="dv">100</span> <span class="op">+</span> date.day
            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">hash</span> <span class="kw">in</span> dias.keys():
                nombredia <span class="op">=</span> date.strftime(<span class="st">&quot;%A&quot;</span>)
                diasemana <span class="op">=</span> date.weekday()
                dias[<span class="bu">hash</span>]<span class="op">=</span>[<span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">24</span>)]
                dias[<span class="bu">hash</span>].insert(<span class="dv">0</span>,nombredia)
                dias[<span class="bu">hash</span>].insert(<span class="dv">0</span>,diasemana)
                <span class="co">#print(&quot;faltaba: {}&quot;.format(hash))</span>

            <span class="co">#print single_date.strftime(&quot;%Y-%m-%d&quot;)</span>


        sorted_x <span class="op">=</span> <span class="bu">sorted</span>(dias.items(), key<span class="op">=</span>operator.itemgetter(<span class="dv">0</span>))
        <span class="cf">for</span> k, v <span class="kw">in</span> <span class="bu">enumerate</span>(sorted_x): 
            width <span class="op">=</span> <span class="bu">len</span>(v[<span class="dv">1</span>])
            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(width):
                <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span>:
                    <span class="bu">print</span>(<span class="st">&#39;</span><span class="sc">{}</span><span class="st">,&#39;</span>.<span class="bu">format</span>(v[<span class="dv">0</span>]), end<span class="op">=</span><span class="st">&#39;&#39;</span>)
                <span class="cf">if</span> j <span class="op">==</span> width<span class="op">-</span><span class="dv">1</span>:
                    <span class="bu">print</span>(<span class="st">&#39;</span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(v[<span class="dv">1</span>][j]))
                <span class="cf">else</span>:
                    <span class="bu">print</span>(<span class="st">&#39;</span><span class="sc">{}</span><span class="st">,&#39;</span>.<span class="bu">format</span>(v[<span class="dv">1</span>][j]), end<span class="op">=</span><span class="st">&#39;&#39;</span>)</code></pre></div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="the-shape-of-the-data.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="building-a-recommender-system.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
